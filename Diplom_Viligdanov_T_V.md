# Тема проекта: автоматическое заполнение документов с использованием языка программирования python
**Цель:**  ознакомиться с библиотекой python-docx, научиться заполнять документ Word  в автоматическом режиме с использованием написанного кода.

**Задачи:**
>•	Изучить литературу по библиотеке python-docx;

>•	Оформить шаблон документа для автоматического заполнения в программе Microsoft Word;

>•	Написать код на языке python для автоматического заполнения документа;

>•	Сформировать готовый текстовый документ в автоматическом режиме.

***Инструменты:*** Microsoft Word, PyCharm.

## Оглавление 

## Глава 1 Инструменты автоматизированного заполнения документов

1.1	Рассмотрение существующих инструментов для автоматизации заполнения документов

1.2	Преимущества использования инструментов автоматического заполнения документов

## Глава 2  Язык программирования Python

2.1	Использование языка программирования Python для автоматизации процессов

2.2	Установка редактора PyCharm  

2.3	 Знакомство с редактором PyCharm

2.4	Знакомство с библиотекой python-docx

## Глава 3 Автоматическое заполнение документа 
3.1 Создание шаблона документа

3.2	Написание кода

Заключение 

Список используемой литературы


# Введение


В современном мире невозможно представить выполнение какой-либо работы с документами без использования специализированных программных продуктов. Для уменьшения времени заполнения документов, минимизации ошибок и увеличения производительности труда, используются программы для автоматического заполнения документов. 
В данной дипломной работе будет рассмотрен процесс формирования конструкторского документа на магнитных носителях данных (МНЗ). Данный документ используется для учета конструкторской документации в архиве предприятия. Формирование МНЗ будет проводиться в автоматическом режиме с использованием написанного кода на языке программирования python, а также с использованием заранее подготовленного в программе Word шаблона. 

# Глава 1 Инструменты автоматизированного заполнения документов
## 1.1 Рассмотрение существующих инструментов для автоматизации заполнения документов


В настоящее время существует большое множество различных программ для автоматического заполнения документов. Рассмотрим некоторые из них.
ParRot – офисная программа предназначенная для автозаполнения бланков различных форм с последующим выводом документа на печать.
Программа умеет работать с дипломами, аттестатами, сертификатами, свидетельствами, грамотами, наградными листами, расходными накладными, счетами-фактурами и многими другими документами, с которыми ежедневно сталкиваются все офисные работники и госслужащие. Поддерживается и быстрое создание "копий документов" с нанесением на них подписей и печатей.
Помимо работы с готовыми шаблонами, ParRot позволяет создавать собственные макеты, добавляя в них любую текстовую информацию и различные графические объекты. Для этих целей, в программе имеется очень удобный специализированный редактор-конструктор с расширенным функционалом. Вдобавок к этому, программа позволяет импортировать содержимое excel-файлов и связывать их с шаблон-макетом, а также сканировать и автоматически распознавать документы для дальнейшего редактирования и распечатки. Функция автоматической адаптации параметров документов под индивидуальные особенности каждого принтера полностью исключает возможность смещения объектов при выводе и печати брака.
Form Pilot Office - программа для работы с электронными и бумажными документами на компьютере, подготовки бланков для клиентов и партнеров. 
Заполнение бумажных бланков - это, без сомнения, "изюминка" программы Form Pilot. Но с таким же успехом в ней можно заполнять электронные формы разных форматов: PDF, HTML, DOC, XLS, TXT и другие. Для этого нужно всего лишь открыть документ в родном приложении и "распечатать" его на принтере Form Pilot Office. 
 
### 1.2 Преимущества использования инструментов автоматического заполнения документов

При использовании специализированных программ для автозаполнения документов пользователь получает множество преимуществ, таких как:
- Снижение трудозатрат на рутинные операции;
- Повышение производительности труда;
- Исключение дублирования работы по вводу информации;
- Возможность коллективной работы над одним документом

# Глава 2 Язык программирования Python
## 2.1 Использование языка программирования Python для автоматизации процессов
Python — это высокоуровневый интерпретируемый язык динамического программирования общего назначения, ориентированный на удобочитаемость кода. Обычно он имеет небольшие программы по сравнению с Java и C. Он был основан в 1991 году разработчиком Гвидо Ван Россумом. Python входит в число самых популярных и быстрорастущих языков в мире. Python — мощный, гибкий и простой в использовании язык. Кроме того, сообщество Python очень активно. Он используется во многих организациях, поскольку поддерживает несколько парадигм программирования. Он также выполняет автоматическое управление памятью.

***Преимущества:*** 

1)	Наличие сторонних модулей 
2)	Обширные библиотеки поддержки (NumPy для числовых расчетов, Pandas для анализа данных и т. д.) 
3)	Открытый исходный код и большое активное сообщество 
4)	Универсальный, легко читать, учиться и писать
5)	Удобные структуры данных 
6)	Язык высокого уровня 
7)	Динамически типизированный язык (нет необходимости упоминать тип данных на основе присвоенного значения, он принимает тип данных) 
8)	Объектно-ориентированный и процедурный язык программирования
9)	Портативный и интерактивный
10)	Идеально подходит для прототипов — обеспечивает больше функциональности при меньшем кодировании
11)	Высокая эффективность (чистый объектно-ориентированный дизайн Python обеспечивает улучшенное управление процессом, а язык оснащен отличными возможностями обработки текста и интеграции, а также собственной структурой модульного тестирования, что делает его более эффективным.)
12)	Возможности Интернета вещей (IoT)
13)	Интерпретируемый язык
14)	Переносимость между операционными системами 


***Недостатки:***

- Производительность: Python — это интерпретируемый язык, а это значит, что он может работать медленнее, чем компилируемые языки, такие как C или Java. Это может быть проблемой для задач, требующих высокой производительности.
- Глобальная блокировка интерпретатора: Глобальная блокировка интерпретатора (GIL) — это механизм в Python, который предотвращает одновременное выполнение кода Python несколькими потоками. Это может ограничить параллелизм и параллелизм некоторых приложений.
- Потребление памяти: Python может потреблять много памяти, особенно при работе с большими наборами данных или выполнении сложных алгоритмов.
- Динамически типизированный: Python — это язык с динамической типизацией, что означает, что типы переменных могут изменяться во время выполнения. Это может затруднить обнаружение ошибок и может привести к ошибкам.
- Упаковка и управление версиями. В Python имеется большое количество пакетов и библиотек, что иногда может приводить к проблемам с версиями и конфликтам пакетов.
- Отсутствие строгости: гибкость Python иногда может быть палкой о двух концах. Хотя это может быть удобно для быстрой разработки и создания прототипов, это также может привести к тому, что код будет трудно читать и поддерживать.
- Крутая кривая обучения. Несмотря на то, что Python обычно считается относительно простым языком для изучения, он все же может иметь крутую кривую обучения для начинающих, особенно если у них нет опыта программирования.

 ***Приложения:***  

- Настольные приложения с графическим интерфейсом
- Графический дизайн, приложения для обработки изображений, игры и научные/вычислительные приложения
- Веб-фреймворки и приложения 
- Корпоративные и бизнес-приложения 
- Операционные системы 
- Образование
- Доступ к базе данных
- Развитие языка 
- Прототипирование 
- Разработка программного обеспечения
- Наука о данных и машинное обучение
- Сценарии

***Организации, использующие Python:*** 

- Google (компоненты паука Google и поисковой системы) 
- Yahoo (Карты) 
- YouTube 
- Мозилла 
- Дропбокс 
- Майкрософт 
- Сиско 
- Спотифай 
- Куора 
- Фейсбук


## 2.2 Знакомство с редактором PyCharm 

**PyCharm** – это специальная среда разработки,  которая поможет  программировать быстрее, проще и чище.
В PyCharm есть все инструменты, чтобы писать, отлаживать и тестировать код. Например, можно быстро исправить программу сразу в нескольких местах, а встроенный форматер приведёт её в соответствие со стандартом PEP 8.
Также IDE позволяет использовать в проектах другие языки программирования, синхронизировать код с системами контроля версий и развёртывать его.
IDE, или Integrated Development Environment — интегрированная среда разработки, набор ПО для создания кода. В него входят специальный редактор для кодинга и ряд инструментов, которые помогают запускать, тестировать и отлаживать код.
Базовый набор функций PyCharm можно расширять с помощью плагинов, которые позволяют, например, настраивать внешний вид интерфейса и подключать дополнительные инструменты.
Для установки PyCharm  нужно перейти на сайт разработчика

>https://www.jetbrains.com/ru-ru/pycharm/download/#section=windows 
    
выбрать требуемый тип ОС, скачать программу и установить ее на свой ПК.
 
## 2.3 Знакомство с библиотекой python-docx
Модуль Python docx позволяет пользователям манипулировать документами, либо изменяя существующий документ, либо создавая новый пустой документ и манипулируя им. Это мощный инструмент, поскольку он помогает вам очень широко манипулировать документом.
Установка библиотеки 
Для установки модуля в терминале программы PyCharm либо другой аналогичной программе необходимо набрать команду:
pip install python-docx
Ознакомиться с документация по этому модулю можно на официальном сайте: 
>https://pypi.org/project/python-docx-1/#files.
 
## 2.4 Знакомство с библиотекой docxtl
Модуль python-docx в основном используется для создания документов MS Word, но не для их изменения. Модуль python-docx-template был создан, для легкого и элегантного создания множества подобных документов из заготовленных шаблонов .docx.
Идея состоит в том, чтобы создать нужный пример/шаблон документа с помощью Microsoft Word. Он может быть настолько сложным, насколько это необходимо: с изображениями, таблицами, колонтитулами, заголовками, в общем все, что можно сделать с Word. Затем вставить в него теги, используемые jinja2, непосредственно там где ожидаются изменения и сохранить полученный шаблон DOCX.
Теперь можно использовать модуль python-docx-template для создания любого количества подобных документов Word из созданного шаблона DOCX, изменяя "на лету" переменные контекста, которые транслируются в теги jinja2.
Для установки модуля необходимо использовать команду:
pip install docxtpl 

## 2.5 Знакомство с библиотекой os

Модуль os в Python — это библиотека функций для работы с операционной системой. Методы, включенные в неё позволяют определять тип операционной системы, получать доступ к переменным окружения, управлять директориями и файлами:
	проверка существования объекта по заданному пути;
	определение размера в байтах;
	удаление;
	переименование и др.
При вызове функций os необходимо учитывать, что некоторые из них могут не поддерживаться текущей ОС.
Чтобы пользоваться методами из os, нужно подключить библиотеку. Для этого в Python используется import os, который необходимо описать в файле до первого обращения к модулю.
Рекомендуется использовать эту инструкцию в начале файла с исходным кодом.

 
# Глава 3 Автоматическое заполнение документа 
## 3.1 Создание шаблона документа

Одной из задач данной дипломной работы является подготовка шаблона документа для автоматического заполнения. Будущий конструкторский документ который должен быть сформирован в автоматическом режиме представляет из себя документ на магнитных носителях данных (МНЗ). МНЗ применяется на предприятиях для учета конструкторской документации. В документе МНЗ содержится информация о различных файлах, которые разрабатывают сотрудники предприятия и передают на хранение в архив предприятия.  На рисунке 1 представлен образец сформированного документа МНЗ.
Для взаимодействия между кодом, написанном на языке python и шаблоном, составленном в программе Microsoft Word используется модуль Jinja2.
Модуль Jinja2 - это современный и удобный язык шаблонов для Python, созданный по образцу шаблонов Django. Он быстр, т.к. компилируется в код Python, широко используется и безопасен благодаря дополнительной среде выполнения изолированных шаблонов.

![Рисунок 1](/mnzForPage1.jpg)



**Преимущества языка шаблонов Jinja2:**

- Автоматическая система экранирования HTML для предотвращения XSS.
- Наследование шаблонов, поддержка макросов.
- Шаблоны компилируются до оптимального кода Python (можно отключить при отладке).
- При отладке, номера строк исключений точно указывают на неправильную строку в шаблоне.
- Настраиваемый синтаксис, много встроенный фильтров.
- Поддержка использования методов стандартных типов Python в шаблонах.
- Возможность вызова функций Python в шаблонах. 


Для управления абзацами, строками таблицы, столбцами таблицы, сериями необходимо использовать специальный синтаксис.
В моем случае нужно добавлять строки к таблице, в которых будут ячейки с автоматически заполняемой информацией и с постоянной информацией.
В моем случае, данные в виде файлов, которые будут добавляться в таблицу берутся из каталога и количество строк в таблице будет зависеть от количества файлов в каталоге. Для того чтобы в таблицу автоматически добавлялись строки, в первую строку необходимо прописать ключевое (служебное) слово - тег в виде:

>{%tr for item in filesRows %}

**Примечание:** _особое внимание хочу обратить на отсутствие пробела в начале тэга между % и tr и наличием пробела между s и % в конце тэга. В противном случае таблица не заполнится данными._

Для того чтобы в ячейку записалась требуемая информация в автоматическом режиме необходимо записать в эту ячейку тег в виде:

>{{ item.data }}
>
>где,
> 
>item – это элемент,
>
>data – данные элемента item.

Если в таблицу или в документ необходимо поместить информацию которая не меняется, тег необходимо записать в виде:

>{{ data }}

В последней строке таблицы необходимо записать тег в виде:

>{%tr endfor %}

Подготовленный шаблон документа МНЗ представлен на рисунке 2.

![Рисунок 1](/shablonForMnzPage2.jpg)

Для формирования МНЗ вышеперечисленных тегов достаточно. Для других случаев формирования шаблона документа для автозаполнения рассмотрим дополнительные теги.
Если в таблице необходимо управлять столбцами таблицы, тег должен быть записан в виде:

>{%tс for item in filesСolumn %}

Если в документ нужно автоматически добавить абзац, тег принимает вид:

>{%p jinja2_tag %}

## 3.2 Написание кода

Для написания кода программы, которая будет автоматически формировать конструкторский документ МНЗ воспользуемся дополнительными модулями python.
Для получения имен, размера и списка файлов которые находятся в указанной директории нам потребуется модуль os python.
Для автоматического формирования документа МНЗ в формате docx нам потребуется модуль docxtpl python.
Опишем алгоритм работы кода:
1 	При помощи модуля os производим считывание всех файлов, расположенных в указанной директории, при этом получаем необходимые нам данные об этих файлах.
2	Производим обработку всех файлов с получением необходимой  информации в том виде в котором эта информация должна быть представлена в документе МНЗ. 
3	Производим заполнение таблицы необходимой информацией.

Рассмотрим в каком виде записывается название файла, который передается в архив предприятия. 

>**АБВГ.ДДДДДД.РРРВВ_<наименование>.ффф**
>
>где,
>
>**АБВГ** – код организации разработчика (в названии файла не присутствует, указывается в МНЗ);
>
>**ДДДДДД** – код классификационной характеристики документа. Определяется по ОК 012–93 «Общероссийский классификатор изделий и конструкторских документов (классификатор ЕСКД);
>
>**РРР** – порядковый регистрационный номер по картотеке предприятия;
>
>**ВВ** – код документа. Наибольшее количество документов которое передается в архив состоит из следующих кодов: СБ -сборочный чертеж, СП -спецификация, МЭ – электромонтажный чертеж, ТЭ4 -таблица соединений, ВП – ведомость покупных изделий.
Остальные виды конструкторских документов представлены в ГОСТ 2.102-2013.
<наименование> - наименование документа
>
>**.ффф** – формат файла

Приступим к написанию кода. Для написания кода я использовал программу PyCharm  с установленными модулями os python и docxtpl python.

Подключаем модуль для работы с операционной системой:

>import os

Подключаем модуль для работы с документами формата Word:

> from docxtpl import DocxTemplate, InlineImage

Далее указываем имя предварительно подготовленного шаблона документа Word:

> doc = DocxTemplate("shablon_mnz.docx")

Вводим переменную в которой будет храниться дата документов которые передаются в архив:

>dateFile = "05.06.2023"

Указываем путь к директории в которой хранятся файлы:

>path = “C:/Users/Files”

Получаем путь к файлу в виде объекта при помощи функции os.path.isfile():

> fun = lambda x: os.path.isfile(os.path.join(path, x))

Лямбда-выражения в языке Python представляют небольшие анонимные функции, которые определяются с помощью оператора lambda. В нашем случае лямбда-выражение возвращает результат выполнения функции os.path.isfile.
Функция os.path.isfile() принимает path в качестве параметра объекта, представляющий путь к файловой системе. Объект, подобный пути, представляет собой либо строку, либо байтовый объект, представляющий путь. Метод os.path.isfile() возвращает логическое значение класса bool. Метод os.path.isfile() возвращает True, если указанный путь является существующим обычным файлом. В противном случае возвращается False.
Производим фильтрацию:

> files_list = filter(fun, os.listdir(path))

Встроенная функция filter() Python может использоваться для создания нового итератора из существующего итерируемого объекта (например списка или словаря), который эффективно отфильтрует элементы с помощью предоставленной нами функции. Итерируемый объект — это объект Python, по которому можно выполнить итерацию, то есть он вернет элементы в такой последовательности, которую мы можем использовать в цикле for.

Базовый синтаксис для функции filter():

>filter(function, iterable)

Это вернет итерируемый объект фильтра. Мы можем использовать функцию, например list(), для составления списка всех элементов, возвращенных в объекте фильтра.
Функция filter() обеспечивает способ фильтрации значений, который зачастую может быть более эффективным, чем генератор списка, особенно когда мы начинаем работу с большими наборами данных. Например, генератор списка составит новый список, что увеличит время этой обработки. Это означает, что после того, как генератор списка закончит выражение, у нас в памяти будет два списка. Однако filter() сделает простой объект, содержащий ссылку на оригинальный список, предоставляемую функцию и индекс пути в оригинальном списке, что занимает меньший объем памяти.
Первый аргумент в filter() — это функция, которую мы используем для решения о включении или фильтрации каждого элемента. Функция вызывается один раз для каждого элемента в итерируемом объекте, переданном как второй аргумент и каждый раз при возвращении False значение сбрасывается. Поскольку этот аргумент является функцией, мы можем либо передать обычную функцию, либо использовать функции lambda, особенно когда выражение является менее сложным.
В целом, функции lambda достигают того же результата с filter(), что и при использовании обычной функции. Необходимость определения обычной функции растет по мере увеличения сложности выражений для фильтрации наших данных, что, скорее всего, будет способствовать улучшению читабельности нашего кода.
Создаем список кортежей файлов из каталога с указанием размера каждого файла:

> size_of_file = [(f, os.stat(os.path.join(path, f)).st_size) for f in files_list ]

Функция stat() модуля os получает статистическую информацию файла или дескриптора файла. Выполняет эквивалент системного вызова stat() по заданному пути. Путь path может быть указан в виде строки или bytes, переданных прямо или косвенно через интерфейс os.PathLike или как дескриптор открытого файла. Функция stat() вернет объект os.stat_result.
Функция join() модуля os.path правильно соединяет переданный путь path к одному или более компонентов пути *paths. Возвращаемое значение представляет собой конкатенацию пути path и компонентов пути *paths с ровно одним разделителем каталогов os.sep, следующим за каждой непустой частью кроме последней. Это означает, что результат будет заканчиваться разделителем только в том случае, если последняя часть пуста.

Если компонент является абсолютным путем, все предыдущие компоненты отбрасываются, и соединение продолжается с компонента абсолютного пути.
В Windows буква диска не сбрасывается при обнаружении компонента абсолютного пути, например r'\foo'. Если компонент содержит букву диска, все предыдущие компоненты отбрасываются и буква диска сбрасывается. Поскольку для каждого диска имеется текущий каталог os.path.join('c:', 'foo') представляет путь относительно текущего каталога на диске C: - c:foo, а не c:\\foo.
Аргументы path и *paths должны быть одного типа и могут быть как байтовыми строками или текстовыми строками. Результатом будет является тот же тип.
Функция os.path.join() может принимать объект, представляющий путь к файловой системе, например такой как pathlib.PurePath.
Создаем пустой список:

>filesRows = [ ]

Создаем цикл for для заполнения каждой строки таблицы:

>for count in range(len(size_of_file)):

Создаем переменную count для автодобавления новой строки в таблицу при каждой последующей итерации:

>count = 0

Пробегаемся по списку size_of_file при помощи цикла for:

>for f, size in size_of_file:

Создаем переменную temp для временного хранения кортежа из списка size_of_file по индексу f:

>temp = str(f)

При помощи функции find производим поиск индекса первой и последней буквы наименования документа:

>start = temp.find('_')
>end = temp.find('.')

Метод find помогает найти индекс первого совпадения подстроки в строке. Если символ или подстрока не найдены, find возвращает -1.
Параметры, которые передаются в метод, — это подстрока, которую требуются найти, индекс начала и конца поиска. Значение по умолчанию для начала поиска — 0, а для конца — длина строки.

Метод find принимает три параметра:
-	substring (символ/подстрока) — подстрока, которую нужно найти в данной строке.
-	start (необязательный) — первый индекс, с которого нужно начинать поиск. По умолчанию значение равно 0.
-	end (необязательный) — индекс, на котором нужно закончить поиск. По умолчанию равно длине строки.

Так как каждый файл имеет разное название, а наименование документа расположено в названии файла между символами <_>  и < . >, поиск индексов start  и end нам нужен для того чтобы извлечь из общего названия файла часть строки с наименованием документа. 
Произведем извлечение части строки с наименованием документа без первой буквы:

> titleDoc = temp[start + 2:end]

Т.к. для заполнения таблицы документа word наименование документа необходимо записывать с заглавной буквы, при помощи функции upper() произведем изменение первой буквы наименования документа на заглавную:

>firstLetter = temp[start + 1].upper()

В названии файла буквы могут быть как строчные, так и заглавные, поэтому для того чтобы не потерять информацию при автозаполнении документа Word, нам необходимо искать и заглавные и строчные буквы. Поэтому для поиска как заглавных так и строчных букв кода документа, нам необходимо ввести две переменные для каждого кода искомого документа. 
Ищем индекс кода СБ состоящий из заглавных букв:

>capitalLetters1 = temp.find('СБ')

Ищем индекс кода “сб” из строчных букв:

>lowerСase1 = temp.find('сб')

Проверяем наличие индексов других кодов документа:

>lowerСase2 = temp.find('вп')  
>
>capitalLetters2 = temp.find('ВП')

>lowerСase3 = temp.find('тэ4')  
>
>capitalLetters3 = temp.find('ТЭ4')

>lowerСase4 = temp.find('мэ')
>
>capitalLetters4 = temp.find('МЭ')

Далее делаем проверку переменных кода документа, если какой-либо код найден, создаем новые переменные, которые необходимо будет вставить в заполняемый документ МНЗ. 

>if lowerСase1 > 0 or capitalLetters1 > 0:
>  
>inDx1 = 'Сборочный чертеж'
>
 >inDx2 = 'СБ'
>
>elif lowerСase2 > 0 or capitalLetters2 > 0:
>
>inDx1 = 'Ведомость покупных изделий'
  >
> inDx2 = 'ВП'
>
>elif lowerСase3 > 0 or capitalLetters3 > 0:
>
>inDx1 = 'Таблица соединений'
>
>inDx2 = 'ТЭ4'
>
>elif lowerСase4 > 0 or capitalLetters4 > 0:
>
>inDx1 = 'Электромонтажный чертеж'
>  
>inDx2 = 'МЭ'

	Если ни один из искомых кодов не найден, присваиваем переменной символ пробела:
>else:
>  
>inDx1 = ' '
>
>inDx2 = ''


Производим разделение разрядов размера файла:

>delimitedFileSize = int(size)
>
>delimitedFileSize = '{0:,}'.format(delimitedFileSize).replace(',', ' ')


	Далее производим определение в какой программе был составлен файл. В нашем случае файлы могут быть сформированы в программе Exel  с расширением .xls, либо в программе AutoCad с расширением .dwg:

>data = str(size_of_file[count])
>
>flag = data.find("dwg") != -1

>if (flag == True):
    name_program = "AutoCad"
else:
    name_program = "Exel"

Далее производим заполнение таблицы нашего шаблона необходимыми переменными:


>filesRows.append({"sNo": count + 1, "name_chertega": firstLetter + titleDoc + "\n" + inDx1, "name_file": f, "program": name_program, "oboznach_file": NameFile + " " + inDx2, "size": delimitedFileSize})

	Для заполнения следующей строки таблицы необходимо произвести увеличение счетчика count:

>count += 1


	Заполняем теги таблицы данные которых не меняются во всем документе:

>context = {
    "filesRows": filesRows,
     "date": DATE,
    "kolich_file": len(size_of_file)
}

Подставляем контекст в шаблон документа МНЗ:

>doc.render(context)

Сохраняем заполненный документ с указанным названием:
>reportWordPath = 'ITOG-MNZ-FILE.docx'
>doc.save(reportWordPath)

Выводим в консоль сообщение о завершении формирования документа:
>print("Формирование документа завершено.")


# Заключение
	В процессе написания дипломного проекта решены следующие задачи:
-  рассмотрены дополнительные модули python;
- составлена подробная инструкция по подготовке и автоматическому заполнению шаблона документа Word;
- написан код на ЯП python для автоматического заполнения  документа МНЗ необходимыми данными;
- сформирован документ МНЗ.



## Список используемой литературы
1.	www.geeksforgeeks.org
2.	https://python-lab.ru
3.	https://metanit.com
4.	www.digitalocean.com















